const natural = require("natural")
var PorterStemmer = natural.PorterStemmer
let specClassifier = new natural.BayesClassifier(PorterStemmer, 0.1)
natural.PorterStemmer.attach()

const trainSpecializationAreasClassifier = async () => {

    ///////////////////////////////////////////////////////////
    //////////////Software Engineering/////////////////////////
    ///////////////////////////////////////////////////////////
    //Software Architectures - ASof
    let objASof = "Teach quality software design methods, techniques, and languages using software architecture and design pattern approaches. Study the methods and techniques that bridge the gap between the problem space and the solution space, providing traceability from system requirements to system design. Read software architectures. Evaluate software architectures. Write software architectures.";
    let progASof = "Software Architectures: The architecture influence cycle; Concepts, Quality Attributes and tactics. Documenting Software Architectures: Architectural Viewtypes and Styles; Module, Component-and-Conector, and Allocation; Context Diagrams; Combined Views; Variability and Dynamism; Choosing the Views. Evaluating Software Architectures: The ATAM Method; The CBAM Method. Software Product Families. Software Architecture Best Practices: Enterprise Architectural Patterns. Case Studies";

    specClassifier.addDocument(objASof, "Software Engineering");
    specClassifier.addDocument(progASof, "Software Engineering");

    //Advanced Programming - PAva
    let objPAva = "Understand advanced programming techniques and their domain of application. Understand programming language limitations and ways to overcome those limitations. Forecast the impact of the use of advanced programming techniques in the development, execution, and maintenance of software. Understand the reflective capabilities of programming languages regarding introspection and intercession at compile-time, load-time, and execution-time. Understand the differences between programming and meta-programming and the usefulness of code models. Understand meta-classes, meta-object protocols, and their intercession capabilities. Understand aspect-oriented programming and its application to cross-cutting requirements. Understand linguistic abstraction, evaluators, and meta-circular evaluators. Understand the implementation of meta-programming, lazy-evaluation and non-deterministic evaluation.";
    let projPAva = "Reflection, introspection and intercession. Reification. Reflexive architectures. Meta-programming and code models. Reflection in Java and Javassist. Meta-object protocols. Protocols in CLOS. Generic functions and method combination. Classes and metaclasses. Protocols for making instances, for accessing instance members and for redefining classes. Aspect-oriented programming. AspectJ. Linguistic abstraction, evaluators and meta-circular evaluators. Macros. Lazy evaluation. Continuations. Direct and continuation-passing style. Non-local control transfer. Non-deterministic evaluation.";

    specClassifier.addDocument(objPAva, "Software Engineering");
    specClassifier.addDocument(projPAva, "Software Engineering");

    ///////////////////////////////////////////////////////////
    //////////////Enterprise and Information Systems///////////
    ///////////////////////////////////////////////////////////

    //Information Systems Project Management - GPI
    let objGPIES = "The objectives of GPI are aligned with the same objectives as defined for the course “IS 2010.4 IS Project Management” of the curriculum “ACM/AIS IS 2010 Curriculum Guidelines”, namely: 1. Understand the concepts of project and project management in the organizational context 2. Understand the project management process groups 3. Understand and properly relate the project management processes with the different projects development lifecycles approaches 4. Make use of project scope planning methods and techniques 5. Make use of project scheduling methods and techniques 6. Identify the project stakeholders, make use of project organization and responsibilities planning methods and techniques and develop the project communication planning 7. Identify the main cost components and be capable to use cost planning methods and techniques to define the project budget 8. Make use of quality planning, quality assurance and quality control in the project management context 9. Make use of risk identification, assessment, treatment and control methods and techniques 10. Understand the procurement management processes and the management of different project contract types 11. Make use of information and tools to support project control, project close and suitable metrics 12. Identify the main Project Manager technical, behavioral and contextual competence elements 13. Understand the concepts of project based organization, change management, project value, programme management, portfolio management and governance of projects. 14. Make adequate use of MS-Project functionalities on practice exercises";
    let projGPIES = "The syllabus of GPI is closely aligned with the course \"IS 2010.4 IS Project Management\" defined in the \"ACM / AIS IS 2010 Curriculum Guidelines\" having the following main topics: 1. Project management related concepts in an organizational perspective 2. Project basics 3. Life Cycles models 4. Scope management 5. Time management 6. Project Organization and Communication management 7. Stakeholders management 8. Cost management 9. Quality management 10. Risk management 11. Procurement management 12. Project control 13. Project closure 14. Project Management competence elements 15. Projects alignment with the Organization and the Business.";

    specClassifier.addDocument(objGPIES, "Enterprise and Information Systems");
    specClassifier.addDocument(projGPIES, "Enterprise and Information Systems");

    //todo descrição potencialmente em mau formato
    //Foundations of Information Systems - AOSI
    let objAOSI = "The learning objectives of Foundations of Information Systems are the subject of \"IS 2010.1 Foundations of Information Systems\" curriculum \"ACM / AIS IS 2010 Curriculum Guidelines\": 1.\tProvide a socio-technical approach to organizational information systems; understand how and why information systems are used in organizations today 2.\tExplain the relationships between the components of technology, people and organization of business information systems 3.\tKnow the main technology components of information systems 4.\tUnderstanding how businesses use information systems to support their activities and create competitive advantages 5. Understanding how information systems enable new forms of trade between individuals, organizations and governments 6.\tMeet new technologies that enable new forms of communication, collaboration and partnerships 7.\tUnderstanding how information systems enable relationships with customers and suppliers, and how they are used to strengthen the organizational structures and business processes 8.\tUnderstand how information systems can support decision making at different levels and functions of organizations 9. Understand how organizations develop and acquire technology and information systems 10.\tUnderstanding the value of investments in information systems, as well as learn how to prepare a business plan for a new information system, including estimated costs and benefits 11.\tMitigate risks, and plan and recover from disasters 12.\tUnderstand how to ensure security of information systems, taking into account both technological and human aspects 13.\tEvaluate the ethical issues of information systems, and the impact of information systems in the fraud and crime";
    let projAOSI = "The syllabus of Foundations of Information Systems is aligned with the course \"IS 2010.1 Foundations of Information Systems\" as defined in the \"ACM / AIS IS 2010 Curriculum Guidelines\". For clarification, the topics, presented below, are labelled with topics from this curriculum and also from the taxonomy of the ACM CCS 2012: 1. Enterprise Information Systems for Global Scale a.\tWhat is an enterprise information system? The role of information systems in organizations today. b.\tHow information systems are transforming business. The \"digital enterprise\". Strategic objectives of information systems. c.\tEmerging trends in information systems. Challenges and opportunities of globalization. d.\tDimensions of information systems (technology, organization and processes). Approaches to information systems: technological, behavioural, and socio-technical (the approach of this course). ACM/AIS IS 2010.1 Characteristics of the Digital World ACM/AIS IS 2010.1 Information systems in organizations ACM/AIS IS 2010.1 Globalization ACM CCS 2012 Information systems > Information systems applications > Enterprise information systems 2. E-Business and Collaboration to the Global Scale a.\tBusiness processes and information systems. b.\tTypes of business information systems. c.\tInterconnect systems for the organization. d.\tConcepts of \"e-business\", \"E-Commerce\" and \"E-Government\". e.\tCollaborative and social systems. i.\tWhat is collaboration? ii.\tWhat is \"social business\"? ACM/AIS IS 2010.1 Information systems in organizations ACM/AIS IS 2010.1 The Internet and WWW > E-business ACM CCS 2012 Information systems > Information systems applications > Enterprise information systems ACM CCS 2012 Information systems > Information systems applications > Collaborative and social computing systems and tools ACM CCS 2012 Applied computing > Electronic commerce ACM CCS 2012 Information systems > Applied computing > Computers in other domains > Computing in government > E-government 3. Information, Organizations and Systems Strategy a.\tWhat is an organization? Impact of information systems in organizations. i.\tEconomic impact ii.\tOrganizational and behavioural impact iii.\tImplications of the Internet in the design and understanding of information systems in organizations b.\tThe use of information systems for competitive advantage. i.\tCompetitive forces model of Porter ii.\tStrategies of information systems to deal with competitive forces ACM/AIS IS 2010.1 Information systems in organizations ACM CCS 2012 Information systems > Information systems applications > Enterprise information systems ACM CCS 2012 Information systems > Information systems applications > Process control systems ACM CCS 2012 Applied computing > Enterprise Computing 4. Ethical and Social Issues in Information Systems a.\tMoral dimensions of the information society. b.\tEthics in the Information Society c.\tMoral dimensions of information systems i.\tPrivacy and freedom in the Internet age ii.\tIntellectual property ACM/AIS IS 2010.1 Information systems ethics and crime ACM CCS 2012 Security and privacy > Human and societal aspects of security and privacy ACM CCS 2012 Social and professional topics > Professional topics > Computing profession > Codes of ethics ACM CCS 2012 Social and professional topics > Computing / technology policy > Intellectual property ACM CCS 2012 Social and professional topics > Computing / technology policy > Privacy policies 5. Security and Information Systems a.\tAbuse and vulnerabilities of systems. b.\tValue of security and control c.\tA security structure and control: i.\tControls in information systems ii.\tRisk management iii.\tSecurity policies iv.\tDisaster recovery and business continuity v.\tThe role of the audits ACM/AIS IS 2010.1 Security of information systems ACM CCS 2012 Security and privacy 6. Operational excellence with enterprise applications a. Enterprise systems b.\tManagement systems in supply chains c.\tSystems for customer relationship ACM/AIS IS 2010.1 Business intelligence > Application systems ACM/AIS IS 2010.1 Enterprise-wide information systems ACM CCS 2012 Information systems > Information systems applications > Enterprise information systems 7. Electronic Commerce a.\tElectronic commerce on the Internet b. Markets and digital goods, global markets c.\tBusiness models ACM/AIS IS 2010.1 The Internet and WWW > E-business ACM CCS 2012 Applied computing > Electronic commerce 8. Knowledge Management a.\tThe value chain of knowledge management b.\tTypes of knowledge management systems c.\tContent Management Systems d.\tKnowledge management and collaboration ACM/AIS IS 2010.1 Business intelligence > Information and knowledge discovery ACM CCS 2012 Information systems > Information systems applications > Collaborative and social computing systems and tools 9. Support Decision Making a.\tBusiness intelligence in the organization b. Decision support for the operational management and middle management c.\tDecision support to executive management: balanced scorecard d.\tDecision support systems for group ACM/AIS IS 2010.1 Business intelligence > Application systems ACM/AIS IS 2010.1 Business intelligence > Information Visualization ACM CCS 2012 Information systems > Information systems applications > Decision support systems ACM CCS 2012 Information systems > Information systems applications > Data mining ACM CCS 2012 Information systems > Applied computing > Enterprise computing > Business process management > Business intelligence 10. Construction of Information Systems a.\tInformation Systems as planned organizational change b.\tAnalysis and design of systems c.\tLife cycles of systems d.\tDesign and management of business processes ACM/AIS IS 2010.1 Valuing information systems ACM/AIS IS 2010.1 Development and acquisition ACM CCS 2012 Social and professional topics > Professional topics > Management of computing and information systems > Project and people management > Systems analysis and design ACM CCS 2012 Social and professional topics > Professional topics > Management of computing and information systems > Project and people management > Systems planning ACM CCS 2012 Social and professional topics > Professional topics > Management of computing and information systems > Project and people management > Systems development 11. Project Management of Information Systems e.\tRunaway projects and system failure f.\tLinking systems projects to the business plan g.\tPortfolio analysis h.\tManaging project risk ACM/AIS IS 2010.1 Valuing information systems ACM/AIS IS 2010.1 Development and acquisition ACM CCS 2012 Social and professional topics > Professional topics > Management of computing and information systems ACM CCS 2012 Social and professional topics > Professional topics > Computing and business > Socio-technical systems 12. Management Information Systems for Global Scale a.\tThe global environment: \"business drivers\" and challenges b.\tLocation Software c.\tSystems integration on a global scale d.\tManaging global systems ACM/AIS IS 2010.1 Globalization > Global information systems strategies ACM CCS 2012 Social and professional topics > Professional topics > Management of computing and information systems ACM CCS 2012 Applied computing > Enterprise computing > Enterprise interoperability";

    specClassifier.addDocument(objAOSI, "Enterprise and Information Systems");
    specClassifier.addDocument(projAOSI, "Enterprise and Information Systems");

    //Enterprise Architecture - APFSI
    let objAPFSI = "1. Understand the lifecycle of enterprise engineering, including governance and processes of organizational transformation. 2. Understanding the fundamental theories underlying business engineering. 3. Understand and apply the principles of enterprise architecture. 4. Understand and use the modeling languages for enterprise architecture, especially the ArchiMate and DEMO. 5. Understanding and using models and frames of reference of organizations by industry. 6. Understand and apply the techniques of business alignment 7. Analyze case studies of real organizations";
    let projAPFSI = "1. Organizational design • organizational ontology • datalogic , infologico and ontological design . • DEMO method • DEMO language 2. Languages modeling Enterprise Architecture • overview of the ratings of Enterprise Architecture : BPMN , REA , EPC , IDEF , YAWL , UML ; • extensions of the basic model and ArchiMate . 3. Enterprise Architectural Frameworks • overview of the enterprise architecture frameworks : 2.0 FEAF , DoDAF , PEAF , IAF , BEN / St . Galen , COBIT , ITIL , IEEE 42010 , Zachman , TOGAF . 4 . Perspectives of Enterprise Architecture • views , views , and view models . • perspective of business and motivational • informational perspective • systemic perspective • infrastructural perspective 5 . Reference Models for Enterprise Architecture • Requirements of a property s Enterprise Architecture Reference Model ; • Examples of Reference Models : Telecommunications , Retail , Financial , ( TAM , eTOM , SID , PCF , SCOR ) 6 . Principles of Enterprise Architecture • standards and principles of enterprise architecture • actual examples 7 . Business representation • representation techniques • automation of business representation 8 . Methods for Enterprise Architecture • \" Business Systems Planning\" • \" Information Systems Architecture \" 9. Alignment of Enterprise Architecture • concepts and types of alignments • benchmarking and measuring alignments 10 . Concepts and Modelling of Information Architecture • informational entities • languages and techniques of information architecture 11 . Concepts of System Architecture • concepts of information systems • systems architecture in ArchiMate 12 . Service Architecture • service-oriented architecture • modeling services • methods for identifying service 13. Concepts of Technology Infrastructure • modeling infrastructure , products and technology modeling capabilities";

    specClassifier.addDocument(objAPFSI, "Enterprise and Information Systems");
    specClassifier.addDocument(projAPFSI, "Enterprise and Information Systems");

    //Data Administration in Information Systems - AOBD
    let objAOBD = "The course on Data Administration in Information Systems aims at providing to students the skills needed to manage, optimize and effectively use modern database systems for managing large volumes of data. Students should be able to: 1. understand the internal mechanisms of a relational Database Management System (DBMS),, including storage management, indexing, processing and optimizing queries, transaction management, concurrency control, and recovery management 2. understand the tasks involved in database administration 3. optimize information access in databases that store very large amounts of data 4. acquire basic knowledge about the various architectures of parallel and distributed databases, including conventional (SQL) and unconventional (NoSQL) database systems.";
    let projAOBD = "The course syllabus for Data Administration in Information Systems mostly includes topics from the Information Management (IM) area in the ACM CS 2013 Curriculum. The course topics, which are presented next, are labeled with the topics from this curriculum, and with the topics from the ACM CCS 2012 taxonomy, for further clarification: 1. Storage (sub-)systems a. Storage technologies (e.g., RAID) b. Replication c. Architectures ACM CS IM/Database Systems > Components of database systems ACM CS IM/Physical Database Design > Storage and file structure ACM CCS 2012 Information systems > Information storage systems > Information storage technologies 2. Indexing algorithms and file organization a. Record storage b. Buffer management c. Data access ACM CS IM/Database Systems > Components of database systems ACM CS IM/Database Systems > Design of core DBMS functions ACM CS IM/Indexing ACM CCS 2012 Information systems > Information storage systems > Record storage systems ACM CCS 2012 Information systems > Database management system engines > Record and buffer management 3. Query processing a. Query execution planning b. Algorithms c. Optimization ACM CS IM/Database Systems > Components of database systems ACM CS IM/Database Systems > Design of core DBMS functions ACM CCS 2012 Information systems > Database management system engines > Database query processing 4. Concurrency control a. Locking protocols b. Timestamping protocols c. Multi-version protocols ACM CS IM/Database Systems > Components of database systems ACM CS IM/Database Systems > Design of core DBMS functions ACM CS IM/Transaction Processing > Concurrency control ACM CCS 2012 Information systems > Database management system engines > Database transaction processing 5. Data recovery a. Logging b. Failure of non-volatile storage c. Backups ACM CS IM/Database Systems > Components of database systems ACM CS IM/Database Systems > Design of core DBMS functions ACM CS IM/Transaction Processing > Failure and recovery ACM CCS 2012 Information systems > Database management system engines > Database transaction processing > Database recovery 6. Database optimization a. Schema-level optimization b. Query optimization ACM CS IM/Physical Database Design > Database efficiency and tuning ACM CCS 2012 Information systems > Database management system engines > Database query processing ACM CCS 2012 Information systems > Database design and models > Relational database model ACM CCS 2012 Information systems > Data structures > Data access methods 7. Index optimization a. Clustering b. Covering indexes ACM CS IM/Physical Database Design > Database efficiency and tuning ACM CS IM/Indexing ACM CCS 2012 Information systems > Information storage systems > Record storage systems > Record storage alternatives ACM CCS 2012 Information systems > Information storage systems > Record storage systems > Directory structures 8. Optimizing the hardware and the operating systems a. Threads, buffers and storage b. Database performance ACM CS IM/Physical Database Design > Database efficiency and tuning ACM CS IM/Transaction Processing > Interaction of transaction management with storage, especially buffering ACM CCS 2012 Information systems > Database management system engines > Record and buffer management ACM CCS 2012 Information systems > Database administration > Database performance evaluation 9. Parallel and distributed databases a. Architectures b. Partitioning c. Algorithms d. Systems based on map-reduce ACM CS IM/Database Systems > Approaches for managing large volumes of data ACM CS IM/Distributed Databases ACM CCS 2012 Information systems > Database management system engines > Parallel and distributed DBMSs > Relational parallel and distributed DBMSs ACM CCS 2012 Information systems > Database management system engines > Parallel and distributed DBMSs > MapReduce-based systems 10. NoSQL databases a. Key-value storage databases b. Document databases c. Column-oriented databases d. Databases for graph data ACM CS IM/Database Systems > Approaches for managing large volumes of data ACM CCS 2012 Information systems > Database management system engines > Parallel and distributed DBMSs > Key-value stores ACM CCS 2012 Information systems > Information retrieval";

    specClassifier.addDocument(objAOBD, "Enterprise and Information Systems");
    specClassifier.addDocument(projAOBD, "Enterprise and Information Systems");

    ///////////////////////////////////////////////////////////
    //////////////Distributed and Cyberphysical Systems////////
    ///////////////////////////////////////////////////////////

    //Design and Implementation of Distributed Applications
    let objPADIDS = "Understand the system level problems underlying the design and development of large-scale applications. Learn the existing solutions concerning the middleware for large-scale applications with emphasis on the models and architectures taking into account non-functional requirements (scalability, performance, etc.). Specify, design, analyse and implement large scale distributed applications as well as its underlying middleware.";
    let projPADIDS = "Part I: System Models System models Synchronous vs asynchronous systems. Message passing vs shared memory. Fault-models. Consistency models and the CAP theorem. System scales: Client server Clusters and Grid Computing Cloud Computing Peer to peer Part II: Abstractions Distributed Coordination: Physical clocks and clock synchronization Logical time and logical clocks Vector clocks Global states and distributed snapshots Mutual exclusion Leader election Distributed agreement Reliable multicast Total order Consensus Group communication and virtual synchrony Distributed transaction processing Concurrency control Distributed atomic commitment Part III: Systems Building large reliable systems Replicated File-systems Lazy replication Peer-to-peer systems. Geo-replicated systems The google case-study";

    specClassifier.addDocument(objPADIDS, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(projPADIDS, "Distributed and Cyberphysical Systems");

    //Internet of Things Interaction Design
    let objIOT2 = "Students should be able to: Understand how Internet of Things (IoT) Interaction Design differs from traditional disciplines of Human-Computer Interaction (HCI); Think beyond “brick” devices (e.g. phones, tablets) to IoT environments and new interaction modalities; Apply Interaction Design techniques to ideate and prototype novel IoT concepts; Gain skills in developing interactive prototypes that combine software and hardware in new ways; Gain a foundation of contemporary and classic research in the fields of Interaction Design and Ubiquitous Computing; Understand challenges in evaluating the user experience of IoT-based systems and environments.";
    let projIOT2 = "1.\tInteraction Design and the Internet of Things a.\tWhat is Interaction Design b.\tWho creates Interaction Design c.\tWhat is the Internet of Things d.\tChallenges of designing for IoT Experiences 2.\tTechniques for Designing User Experiences a.\tSketching b.\tThe design funnel c.\tSketching with templates and foam core d.\tCreating sequential and narrative storyboards e.\tUser research techniques: Uncoverting the mental model, Wizard of Oz, and Think Aloud 3.\tPrototyping tools for the Internet of Things a.\tArduino for interactive objects b.\tKinect sensors for interactive spaces 4.\tDisciplines of Human-Computer Interaction within the Internet of Things a.\tTangible interaction b.\tWearable interaction c.\tContext-aware environments 5.\tInput and Output Technologies for IoT a.\tTouchscreens, from smartwatches to wall displays b.\tVoice interaction c.\t3D gestures d.\tOther input modalities from accoustic input to brain signals e. Audio output f.\tHaptic feedback, from vibrotactile to muscle-propelled feedback g.\tOther output modalities 6.\tEvaluating User Experience of IoT systems a.\tChallenges b.\tResearch methods c.\tQualitative and Quantitative analysis";

    specClassifier.addDocument(objIOT2, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(projIOT2, "Distributed and Cyberphysical Systems");

    //Applications and Computation for the Internet of Things
    let objIOT = "Students should be able to design, develop, integrate and test cyber-physical systems for the Internet of Things (IoT) with a focus on the requirements and restrictions of cyber-physical interfacing and related software. To study the control and evaluation of cyber-physical interfaces, system-software architectures, and common design patterns; design and performance evaluation of constrained systems (power, memory). Relevant case studies: widespread technologies (identification based on smart cards and tags and biometrics); widespread devices (sensors in smartphones).";
    let progIIOT = "1.\tCharacteristics of cyber-physical systems in the IoT: requirements, life cycle, economy. 2.\tInput/Output interface and devices. Modes of service. Interfacing the physical world – cyber-physical interfaces (logical interaction with sensors and actuators). Performance evaluation (latency, bandwidth, precision, resolution). 3.\tSystem-software architectures – Run-time platforms: Round robin, function-queue scheduling, multitasking; preemption, scheduling (RMS, EDF). Performance evaluation: workload, latency, reliability. 4.\tSoftware design patterns. Non-functional requirements: execution time, energy management, memory usage. 5.\tReal-time systems. 6.\tFault tolerance. 7.\tDesign and development of embedded systems. System specification. Development and life cycles. 8. Case studies: widespread technologies – electronic identification (smart cards and tags) and biometrics; widespread devices (sensors in smartphones). 9.\tAdvanced topics: Co-design, sensor networks. 10.\tSeminar.";

    specClassifier.addDocument(objIOT, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(progIIOT, "Distributed and Cyberphysical Systems");

    //Mobile and Ubiquitous Computing - CMov
    let objCMov = "Understand the fundamental challenges and problems underlying the design and development of software (middleware and operating system) supporting applications for mobile and ubiquitous scenarios (users, hardware, software). Design, specify, analyse and implement software systems (mobile/ubiquitous middleware and operating system) that can support mobile/ubiquitous applications.";
    let projCMov = "Introduction. Fundamental challenges and problems of mobile and ubiquitous computing. Replication (caching, staging, hoarding), consistency and synchronization. Resource discovery and usage (cyberforaging). Mobility, location, context-awareness and adaptability. Battery consumption. Security. Communication, ad-hoc and sensor networks. Mobile code, mobile agents. Middleware and examples of applications, architecture of applications (Android).";

    specClassifier.addDocument(objCMov, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(projCMov, "Distributed and Cyberphysical Systems");

    //Parallel and Distributed Computing - CPD
    let objCPDDS = "Understanding the models, techniques, and programming methods for parallel algorithms. Analyzing and designing parallel algorithms. Understanding the foundations of distributed computing.";
    let projCPDDS = "Parallel computing models: multiprocessors and multicomputers. Memory organization; communication complexity. Interconnection networks. Flynn’s taxonomy. Programming message-passing systems: MPI. Programming shared memory systems: OpenMP, threads, race conditions, deadlock detection. Analysis and synthesis of parallel algorithms: problem partitioning; data organization; synchronization; balancing and scheduling. Performance analysis for parallel algorithms. Foundations of distributed computing and their applications to parallel algorithms. Limits of parallel computing. Analysis of parallel algorithms: sorting algorithms; numerical algorithms, matrix multiplication, solving systems of linear equations; algorithms on graphs; search and optimization algorithms.";

    specClassifier.addDocument(objCPDDS, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(projCPDDS, "Distributed and Cyberphysical Systems");

    //Highly Dependable Systems - SDTF
    let objSDTFC = "To provide an integrated perspective of dependable computing, addressing the mechanisms required to tolerate different types of faults, from accidental to malicious faults, including intrusions. The course addresses the security and fault-tolerant aspects of the system design.";
    let projSDTFC = "1) Dependability fundamentals a) Taxonomy (fault, error, failure) b) Reliability, availability, maintainability, safety, security c) Fault assumption and coverage d) Space, Time, and Value redundancy. Coding. Triple Modular Redundancy e) Error processing. Backward and forward recovery. f) Failure detection and system diagnosis. Watchdogs 2) Secure Hardware a) Security devices b) Smartcards c) Trusted Platform Module d) Biometric Systems 3) Securing the system a) Physical security b) Physical protection of systems c) Intrusion tolerance 4) Byzantine fault tolerance a) Byzantine Leader Election b) Byzantine Broadcast c) Byzantine Memory d) Byzantine Consensus e) Byzantine Replicated State Machines 5) Human Factors a) Human factors in security b) Social engineering";

    specClassifier.addDocument(objSDTFC, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(projSDTFC, "Distributed and Cyberphysical Systems");

    //Cloud Computing and Virtualization - AVExe
    let objAVExe = "Attain an integrated perspective of cloud computing and virtualization, with combined approaches for the design of modern large scale and distributed computing systems, and with their underlying mechanisms and algorithms. Understand a vertical approach to the various virtualization and cloud computing technologies, enhancing applications and services with improved flexibility, resource and economic efficiency, scalability and adaptability. To be able to develop reliable and scalable systems and applications, on cloud computing over current virtualization platforms and applications models. To be able to assess and evaluate solutions, given the alternatives and tradeoffs involved in the employment and management of virtualization infrastructure for cloud computing.";
    let projAVExe = "Introduction to Virtualization and Cloud Computing, Infrastructure-as-a-Service, Platform-as-a-Service, Software-as-a-Service. System-level virtualization: system VM architecture, CPU virtualization, OS core, memory, I/O; hardware support for virtualization, case studies (VMWare, QEMU/KVM, Xen). Cloud computing systems (Amazon EC2, OpenStack, XenCloud, OpenNebula); VM scheduling, migration and replication; monitoring and scalability (CloudWatch, Autoscaling). Process-level virtualization: Java VM specification and reference implementation, security model, code management and binary translation, just-in-time compilation and optimization, garbage collection, case studies (Jikes RVM). Cloud computing platforms (Azure, Google App Engine); distributed virtual machines; monitoring and scalability (Azure Fabric Controller). Data and Storage services: block storage, file storage, key-value stores (Dynamo, S3, Datastore), tabular storage (BigTable, Percolator). Cloud computing scalability: Map-reduce, dataflows (Pig, Dryad, OOzie), streams (S4), applications, monitoring, elasticity and optimization. Cloud computing cross-cutting concerns: virtualization energy efficiency, dynamic provisioning, energy centered cloud design.";

    specClassifier.addDocument(objAVExe, "Distributed and Cyberphysical Systems");
    specClassifier.addDocument(projAVExe, "Distributed and Cyberphysical Systems");

    ///////////////////////////////////////////////////////////
    /////////////Interaction and Visualization/////////////////
    ///////////////////////////////////////////////////////////

    //Three-Dimensional Vizualization and Animation - AVT
    let objAVT = "This course introduces design and development techniques for 3D real-time interactive applications by using graphic APIs such as Modern OpenGL and WebGL. It includes the development of an immersive 3D game for mobile devices by using a low-cost VR glasses set. The course covers also the latest advances in GPU technology and their applications to simulation and computer games. Students should be able to describe and justify methods, procedures and example systems used in Real-Time Interactive Virtual Environments, by identifying the underlying terms, concepts and base principles.";
    let projAVT = "Real-Time Image Synthesis, 3D Viewing Pipeline (Modern OpenGL and WebGL), GLSL Shading language programming, Scenes description formats, 3D Geometric Transformations; Visual Appearance: advanced Lighting and Texturing (Bump mapping and Environmental mapping); Collision Detection, Special visual effects: lens flare, stencil, billboards, particle systems; Stereoscopic effect; Acceleration Techniques for games and simulators";

    specClassifier.addDocument(objAVT, "Interaction and Visualization");
    specClassifier.addDocument(projAVT, "Interaction and Visualization");

    //User Centered Design - CCU
    let objCCU = "Understand the basic principles and the methodologies of interactive systems user centred design. Understand users and their needs, how to really acquire them, and the need of user involvement in interactive systems design and implementation. Adapt the above knowledge to user centered design methodologies. Design and implement an interactive system involving real users at various levels in light of the above.";
    let projCCU = "Lectures: Introduction to User Centered Design. Users and Stakeholders. Inquiring Users and Experts. Observing Users. User Involvement and Participation. User Needs and Requirements. Usability Engineering. Data Analysis and Interpretation. Building Prototypes. Interface Types. Affective Aspects. Accessibility. Ethics in User Centered Design. Laboratory: Workshops with the following themes: Who are the Users? What the Users want? Applying Cultural Probes Workshops with Users Initial Requirements Validation of Requirements Conceptual Model and First Low Fidelity Prototypes. Usability Testing. Low Fidelity Prototypes. Functional Prototype.";

    specClassifier.addDocument(objCCU, "Interaction and Visualization");
    specClassifier.addDocument(projCCU, "Interaction and Visualization");

    //Information Visualization - VI
    let objVI = "This course introduces design and development techniques for 3D real-time interactive applications by using graphic APIs such as Modern OpenGL and WebGL. It includes the development of an immersive 3D game for mobile devices by using a low-cost VR glasses set. The course covers also the latest advances in GPU technology and their applications to simulation and computer games. Students should be able to describe and justify methods, procedures and example systems used in Real-Time Interactive Virtual Environments, by identifying the underlying terms, concepts and base principles.";
    let projVI = "Real-Time Image Synthesis, 3D Viewing Pipeline (Modern OpenGL and WebGL), GLSL Shading language programming, Scenes description formats, 3D Geometric Transformations; Visual Appearance: advanced Lighting and Texturing (Bump mapping and Environmental mapping); Collision Detection, Special visual effects: lens flare, stencil, billboards, particle systems; Stereoscopic effect; Acceleration Techniques for games and simulators";

    specClassifier.addDocument(objVI, "Interaction and Visualization");
    specClassifier.addDocument(projVI, "Interaction and Visualization");

    //Interactive Visual Communication - CVI
    let objCVI = "The goal is to provide students with knowledge and competencies needed for the effective communication of concepts, trneds and information based on interactive graphic applications. We’ll describe the relevant specificities of different data types that can be used to communicate, and the best way of using and combining them towards that end. Next, we’ll teach metadata and descriptor extraction techniques from the different media, with an emphasis in images, thus allowing their more efficient manipulation and usage. Indexing and retrieving media based on that metadata will be studied next. Possessing the data in an easy to use format, students will then learn how to visually represent and explore them, interactively. Finally, we’ll approach the question of how best to present concepts, trends and information with the creation of public multimedia presentations, maximizing their impact and the amount of information apprehended by the audience.";
    let projCVI = "1.\tIntroduction 2.\tImages and other Media 3.\tMetadata and Content Information 4.\tThe special case of personal information: PIM and Lifelogging 5.\tFeature Extraction and Indexing 6.\tRetrieval evaluation 7.\tGraphic design principles 8.\tHuman Factors 9. Communicating with data 10.\tPhotography, Video and Animations 11.\tMultimedia Presentations";

    specClassifier.addDocument(objCVI, "Interaction and Visualization");
    specClassifier.addDocument(projCVI, "Interaction and Visualization");

    //Multimedia Content Production - PCM
    let objPCM = "Know the different types of multimédia information and how to manipulate them to poduce multimedia content. To understand the technological constraints that affect Production. To understand critical factors affect the success of a production, namely in aspects such as capture, encoding, processing and visualization of the different media. To know the different kinds of available authoring tools. To create Multimedia contents; To identify the different contexts in which multimedia can be consumed, with emphasys on online and network issues (evaluate bandwidth, latency, synchronization, etc.) and mobile devices. Introduce some advanged multimedia usages such as procedural modelling, generative art augmented reality. Apply efficient methods of multimedia content retrieval.";
    let projPCM = "1.\tMultimedia Data Types a.\tText b.\tBitmap Images c.\tVector Images and SVG d.\tSound e.\tVideo f.\tAnimations 2.\tProcessing and Visualization of multimedia signals 3.\tCapture and encoding of multimedia information 4.\tMultimedia design principles 5.\tLinear and Non-Linear edition of audio and video 6.\tSynchronization 7.\tScripting languages and interactive applications 8.\tMultimedia and networks 9.\tMobile multimedia 10.\tAdvanced multimédia applications 11.\tContent-based multimedia retrieval 12.\tMultimédia databases";

    specClassifier.addDocument(objPCM, "Interaction and Visualization");
    specClassifier.addDocument(projPCM, "Interaction and Visualization");

    //3d Programming - PSJ
    let objPSJ = "This course introduces the concepts and theory of a modern photorealistic rendering. Through the ideas and software in this course, the students will learn to design and develop a rendering system for creating stunning imagery. It covers also the development of a Unity 3D-based application by using its Assets library and the built-in shaders for photorealistic appearance.";
    let projPSJ = "Rendering Equation, Photorealistic Rendering and the Ray-Tracing Algorithm, Geometry Intersection techniques, Acceleration Structures: Grids, KD-Trees and Bounding-Volumes Hierarchy; Materials, Monte Carlo Integration, BRDF and Light Sampling, Combined Sampling & Path Tracing, Photon Mapping, Unity 3D game engine: GUI, game objects and components, lights, materials, rigid bodies, scripting, input and character control, cameras, prefabs, colliders, triggers and shaders.";

    specClassifier.addDocument(objPSJ, "Interaction and Visualization");
    specClassifier.addDocument(projPSJ, "Interaction and Visualization");


    ///////////////////////////////////////////////////////////
    /////////////Intelligent Systems///////////////////////////
    ///////////////////////////////////////////////////////////

    //Search and Planning - PPla
    let objPPla = "•\tDeepen the themes of searching solutions for complex problems and planning actions. •\tIdentify the different types of problems to be solved. •\tMaster the main search methodologies and strategies. •\tSelect the methodology and strategy to apply for each problem type. •\tBe capable of solving reasonably complex search problems. •\tUnderstand the specificity of the problem of planning actions and why it needs a more powerful approach. •\tStudy the foundations and approaches to planning and be capable of solving simple planning problems.";
    let projPPla = "PART 1 – SEARCH 1.\tHEURISTICS AND PROBLEM REPRESENTATION a.\tTypes of Problems b.\tSearch Spaces versus Problem Reduction c.\tHeuristics d.\tConstructive Formulation versus Reparative Formulation e.\tSatisficing, Optimising and Semi-optimising tasks f.\tGenerate-and-Test versus Split-and-Prune paradigms g.\tSystematic Search versus Local Search 2.\tBASIC HEURISTIC SEARCH STRATEGIES a.\tLocal Search (Hill-Climbing) b.\tUninformed Systematic Search (LIFO and FIFO Strategies and AND/OR Graph Search) c.\tInformed Systematic Search (Best-First Search, BF, GBF e GBF*) d.\tSpecialised Best-First Strategies (Z*, A*, AO e AO*) e.\tHybrid Strategies 3.\tADVANCED HEURISTIC SEARCH STRATEGIES a.\tMemory-bounded strategies i.\tMinimalist strategies (IDS Uni- AND Bi-directional, IDA*, RBF and IBS) ii.\tMaximalist strategies (SMA*) MEMORY-BOUNDED STRATEGIES b.\tTime-bounded strategies i.\tQuasi-Optimal Strategies (A* with static weights and with dynamic weights, A*-epsilon) ii.\tLocal Search Advance strategies – Meta-Heuristics (Hill-climbing improved versions, Simmulated Annealing, Deterministic and Stochastic Local Beam Search, Genetic Algorithms) iii.\tNon-systematic Partial Search Strategies •\tIterative Sampling Strategies (1-samp, ISS i-samp, r-samp) •\tBounded Backtracking Search (BBS) and Multi-sampling •\tRestart Depth First Search (RDFS) •\tStochastic Iterative Breadth Search (SIB) i)\tLimited Discrepancy Search 5.\tCONSTRAINT SATISFACTION PROBLEMS a.\tFormalization i)\tConstraint graphs ii) Incremental and Complete-State Formalizations iii)\tTypes of Constraint Satisfaction Problems iv)\tUnary, binary and Global Constraints v)\tAbsolute Constraints versus Preference Constraints b.\tBacktracking Search for CSPs i)\tVariable and Value Ordering ii)\tConstraint Propagation iii)\tForward checking: Antecipation iv)\tSpecial Constraints v)\tIntelligent Backtracking c.\tLocal Search for CSPs d.\tProblem Structure 6.\tSEARCHING WITH OTHER KNOWLEDGE SOURCES a.\tSubgoals i)\tIndependent ii)\tSerialisable iii)\tNon-Serialisable iv) Block-Serialisable b.\tMacro-Operators i)\tNon-Serialisable Subgoals ii)\tArbitrary Single-Goal Search Spaces iii)\tArbitrary Search Spaces c.\tAbstraction i)\tSubset Model versus Region Model ii)\tSingle-level Abstraction iii)\tMulti-level Abstraction PART 2 – PLANNING 1. CLASSICAL PLANNING a.\tFrom Problem Search to Planning b.\tPlanning in Situation Calculus c.\tThe Planning Problem i.\tPlanning Problem Languages ii.\tRepresentation of states, goals, and actions iii.\tPreconditions and Effects iv.\tExpressivity and Extensions d. Planning by searching on a situation space i.\tTotal-order Planning ii.\tForward versus Backward Search iii.\tHeuristics e.\tPlanning by searching on a plan space i.\tPartial-order Planning ii.\tLeast-Commitment Principle iii.\tLinearizations iv.\tComponents of a partial-order plan v.\tPlanning with unassigned variables f.\tPlanning Graphs i.\tPlanning Graphs for heuristic estimation ii.\tGRAPHPLAN Algorithm iii. GRAPHPLAN Termination 2. PLANNING AND ACTING IN THE REAL WORLD a.\tTime, Schedules and Resources i.\tRepresenting temporal and resource constraints ii.\tSolving Scheduling Problems b.\tHierarchical Planning i.\tHigh-level actions ii.\tSearching primitive solutions iii.\tSearching abstract solutions c.\tPlanning and Acting in Nondeterministic Domains i.\tSensorless Planning ii.\tContingent Planning iii.\tOnline Replanning d.\tMultiagent Planning i.\tPlanning with Multiple Simultaneous Actions ii.\tPlanning with Multiple Agents: Cooperation and Coordination";

    specClassifier.addDocument(objPPla, "Intelligent Systems");
    specClassifier.addDocument(projPPla, "Intelligent Systems");

    //Autonomous Agents and Multi-Agent Systems - AASMA
    let objAASMA = "•\tTo acquire general notions about agents and multi-agent systems; knowing how to identify and classify agents and environments, according to different properties. •\tKnowing how to develop complex systems and systems from different application areas, using an agent-oriented methodology. •\tKnowing how to define a society of agents in order to solve a specific problem. •\tBeing able to design agents with reactive, deliberative and hybrid architectures. •\tBeing able to create societies of agents that communicate, in a practical way, using suitable languages and platforms.";
    let projAASMA = "1.\tAgents and Environments a.\tThe concept of agent. b.\tProperties of agents. c.\tProperties of environments. d.\tApplications. e. Abstract agent architectures. 2.\tReactive Architectures a.\tPurely reactive agents. b.\tBrooks’ subsumption architecture. 3.\tDeliberative Architectures a.\tThe intentional stance. b.\tThe BDI model. Practical reasoning agent architectures. c.\tProcedural Reasoning System. 4. Hybrid Architectures a.\tHorizontal and vertical hybrid architectures. b.\tTouringMachines and InteRRaP. 5.\tEmotion-based Architectures a.\tAppraisal theories. b.\tThe concept and role of emotion. c.\tAgents with emotions. d.\tImpact on the studied architectures. e.\tExisting models and systems. 6.\tSocieties of Agents and Emergence a.\tSocieties of agents. Stigmergy, self-organization and emergence. b. Case studies - Game of life, BOIDS and crowds. 7.\tGame Theory a.\tIntroduction to game theory – fundamental concepts and properties. b.\tThe prisoner’s dilemma. Nash equilibrium. c.\tRepeated games. 8.\tCommunication among Agents a.\tCommunication. b. Speech acts. c.\tSemantics. KQML and KIF. FIPA-ACL. 9.\tCoordination and Cooperation among Agents a.\tCooperative distributed problem solving. b.\tThe Contract Net protocol. 10.\tNegotiation among Agents a.\tNegotiation - mechanisms/protocols and strategies. b. Auctions – characteristics and types of auction. c.\tNegotiating/bargaining in task-oriented domains. Monotonic Concession Protocol and Zeuthen Strategy. 11.\tAgent Development a.\tAgent-oriented programming. b.\tMethodologies and pitfalls in the development of agents and multi-agent systems. 12.\tMachine Learning in Agents a.\tReinforcement learning in single-agent scenarios and multi-agent scenarios. Q-learning. b.\tThe problem of coordination. 13.\tHuman-agent interaction. 14.\tApplications of agents and multi-agent systems.";

    specClassifier.addDocument(objAASMA, "Intelligent Systems");
    specClassifier.addDocument(projAASMA, "Intelligent Systems");

    //Learning and Intelligent Decision-Making - ADI
    let objADI = "1.\tUnderstand the main issues involved in decision-making both in uncertain and in adversarial scenarios 2.\tBe familiar with the main methods for planning and learning in such scenarios";
    let projADI = "1.\tIntroduction 2.\tDecision-making in the face of uncertainty: a.\tExpected utility. Decision theory and optimization. b.\tMarkov chains. Control and observability in Markov chains. c.\tMarkov decision processes (MDPs). State and state-action value. Policy and optimal policy. d.\tValue iteration for policy evaluation. Policy iteration. Convergence. e.\tValue iteration for policy optimization. Convergence. f. Partially observable Markov decision processes (POMDPs). Beliefs. Planning in POMDPs. Point-based methods. 3.\tDecision-making in adversarial scenarios: a.\tNormal form games. Best response. Nash equilibrium. b.\tSequential games. Extended form. Stochastic games. c.\tThe computation of Nash equilibria. Complexity. 4.\tLearning: a.\tDecision theory and Bayesian inference. The Bayes optimal classifier. b.\tBayes nets. Inference in Bayes nets. The max-sum algorithm. c.\tLearning of sequential models. The forward-backward (or Baum-Welch) algorithm. Application to POMDP model learning. 5.\tLearning and decision-making: a.\tActive learning. Learning theory. b.\tOnline learning. The weighted majority algorithm. Bandits. c.\tStochastic bandits. Regret. The UCB algorithm. Regret bounds. d. Adversarial bandits. The EXP3 algorithm. Regret bounds. e.\tLearning in MDPs (reinforcement learning, RL). Model-based reinforcement learning. f.\tValue-based reinforcement learning: TD-learning and Q-learning. Convergence. 6.\tApplications: a.\tTD-Gammon: Application of RL to backgammon. b.\tBandits and planning: Monte-carlo tree search. The UCT algorithm and its application to Go.";

    specClassifier.addDocument(objADI, "Intelligent Systems");
    specClassifier.addDocument(projADI, "Intelligent Systems");

    //Knowledge Representation and Reasoning - RCR
    let objRCR = "1. Give an overall view about existing advanced knowledge representation and reasoning systems (beyond First Order Logic, FOL). 2. Understand how to represent knowledge and reason in each one of these families 3. Know the advantages and disadvantages, limitations weak points of each family 4. Be able to choose the more appropriate system to a particular knowledge representation and reasoning problem. 5. Be able to build a knowledge based systems according to each family 6. Be able to represent and solve reasonably complex knowledge representation and reasoning problems. 7. Be able to represent and share large knowledge bases.";
    let projRCR = "1. Introduction: Knowledge, Representation and Reasoning. Declarative Knowledge and Procedural Knowledge. The Knowledge Representation Hypothesis. Knowledge Based Systems. The importance of representing knowledge and of reasoning with it. Soundness and Completeness. The Knowledge and Symbol Levels. 2. Some interesting applications of Knowledge Representation and Reasoning. 3. First Order Logic. Syntax, Semantics, Pragmatics. Implicit and Explicit Believes in Knowledge Based Systems in FOL. 4. Expressing Knowledge: steps to create a knowledge base in FOL. 5. Resolution: Propositional Case, Handling Variables and Quantifiers 6. Dealing with computational Intractability: FOL, Herbrand base, Propositional Logic, SAT solvers, MGU, refinements. Reasoning with Horn Clauses 7. Procedural Control of Reasoning 8. Knowledge Based Systems: definition, components, techniques, success cases, application areas in which they are appropriate, problems and limitations. Analysis of a successful expert system (for instance in medical diagnosis MYCIN - how did it work). 9. Rules in Production Systems. 10. Object Oriented Representation: key ideas. A generic system (representation and reasoning). Analysis of a particular frame system. Advanced Frame Systems (for instance, KEE): representation and reasoning. Representing knowledge in a Frame System to solve a problem. Advantages and disadvantages, problems and limitations. 11. Representing Knowledge in Description Logics. The key ideas behind Description Logics. The Boxes (T and A), intrinsic and contingent properties. A particular DL: syntax and semantics. Reasoning in DL's. Subsumption and Satisfaction. Representing a problem in DL. Classification. Beyond the Basics. Applications of DL's. 12. Semantic Web and Ontologies. Semantic Web and Ontologies. DL's and Ontologies. 13. Inheritance networks: Translational versus topological approaches. Strict and Defeasible Inheritance. Topological strategies to solve Inheritance: shortest path and inference distance. Solving Inheritance using a complete topological approach: support, specificity, preemption and redundancy. The notion of Extension. Credulous and Preferred Extension. Credulous and Skeptical Inheritance. 14. Motivation to non-monotonic logics. Reasoning by default and non-monotonicity. A non-monotonic logic, for instance Reiter's Default Logic. Default rules, default extensions, multiple extensions. Representing problems in Default Logic. Computing extensions through the syntactical system. Examples of theories with no extensions, one extension, several extensions. Interesting results for normal default theories, and for Semi-normal default theories. Advantages and disadvantages, problems and limitations. Objections to Non-Monotonic Logics 15. Uncertainty and Degrees of Belief 16. Explanation and Diagnosis.";

    specClassifier.addDocument(objRCR, "Intelligent Systems");
    specClassifier.addDocument(projRCR, "Intelligent Systems");

    //Social Robo`s and Human-Robot Interaction - RSIPR
    let objRSIPR = "1.\tTo create and implement AI mechanisms that give a robotic platform the capability to interact in a social manner with humans. 2.\tBe capable of integrate and evaluate features such as intentionality, emotions, collaboration into the interaction between humans and robots in different application contexts.";
    let projRSIPR = "1.\tIntroduction 2.\tSocial Robots. Types and examples. Main characteristics. 3.\tSocial Agents architectures. Main components. Sensors and actuators for social robots. 4.\tInteraction design for social robots. Interaction through voice, language and gestures. 5. Intentionality in Robots 6.\tEmotions and emotional robots. 7.\tSocial learning. Imitation. 8.\tCollaboration between humans and robots. 9. Different application domains: manufacturing; autonomous cars; robots at home; entertainment and educational robotics. 10. Experimental design and evaluations of interaction between humans and robots";

    specClassifier.addDocument(objRSIPR, "Intelligent Systems");
    specClassifier.addDocument(projRSIPR, "Intelligent Systems");

    //Robotic Systems in Manipulation
    let objRSIPR2 = "This course aims to expose students to the major related topics in robot manipulation, given from a computer science perspective. A high-level approach is adopted, where the student is first exposed to the software/hardware architectural specificity of a robot manipulator cell. Hands-on robot programming will be constant throughout the course using state of the art development environments such as open source research oriented ROS as well as industrial robot languages such as ABB RAPID and KUKA KRL, available at the robotics lab of the Department of Mechanical Engineering. The course concludes with advanced topics in manipulation involving visual feedback and force feedback in various application scenarios such as industrial co-worker, medical and surgical, in human-friendly environments.";
    let projRSIPR2 = "1. Introduction 2. Requirements of Robot Architectures a. Modularity and Hierarchy b. Layered Robot Control Architectures c. Fault tolerance and redundancy 3. Robot Operating System (ROS) 4. Industrial Manipulation Robots - ABB RAPID architecture and the IRB-140 Industrial Robot 5. Service Manipulation Robots - KUKA KRL architecture and the KUKA collaborative robot 6. Human-in-the-Loop: pHRI - physical Human Robot Interaction 7. Co-manipulation and Tele-manipulation architectures 8. Robot programing by demonstration 9. Visual Servoing and Visual Tracking";

    specClassifier.addDocument(objRSIPR2, "Intelligent Systems");
    specClassifier.addDocument(projRSIPR2, "Intelligent Systems");

    //Machine Learning
    let objRSIPR4 = "This course aims to provide a complete and up-to-date introduction to key concepts in machine learning. After completing the course, students should be able to: •\tUnderstand the main challenges involved in machine learning. •\tUnderstand and correctly apply the steps needed to train and validate a model that is able both to explain a set of data and make predictions about unseen data. •\tUnderstand and correctly apply the more common machine learning algorithms, recognizing their corresponding domain of application.";
    let projRSIPR4 = "1.\tIntroduction to Machine Learning 2.\tBackground a)\tProbability and information theory b)\tLinear algebra c)\tOptimization 3. Introduction to supervised learning - Linear Methods a)\tLinear regression b)\tLogistic regression and perceptron 4.\tFundamentals of learning theory a)\tThe bias-variance tradeoff b)\tOverfitting and underfitting c)\tRegularization d)\tModel selection e)\tStatistical learning theory 5.\tSupervised learning - Non-parametric methods a)\tk-nearest neighbors b)\tLocally weighted regression 6.\tSupervised learning - Decision Trees and ensemble methods a)\tDecision trees b)\tRegression trees c)\tEnsemble methods 7.\tSupervised learning - Bayesian methods a)\tNaive Bayes b)\tBayesian linear regression c)\tBayes nets 8.\tSupervised learning - Kernel methods a)\tMax-margin classifiers b)\tKernel regression 9.\tSupervised learning - Artificial neural networks a)\tMultilayer perceptron b)\tBackpropagation c) Convolutional networks d)\tRecurrent networks e)\tRegularization 10.\tUnsupervised learning a)\tk-means b)\tMixture models and Expectation-Maximization c)\tPCA and ICA d)\tAutoencoders 11.\tApplications a)\tText classification b)\tImage classification";

    specClassifier.addDocument(objRSIPR4, "Intelligent Systems");
    specClassifier.addDocument(projRSIPR4, "Intelligent Systems");

    //Data Science
    let objRSIPR5 = "Students should be able to: •\tUnderstand the statistics and data processing concepts used in complex information processes. •\tDesign systems for knowledge discovery processes automation, and communication of their outcomes using the appropriate algorithms and validation methods at each stage. •\tUnderstand the techniques for frequent patterns recognition and outlier detection in data sets. • Identify sensitive data that might be subject to processing restrictions and data anonymization techniques that enable privacy-preserving data mining, •\tAddress large-scale data processing challenges.";
    let projRSIPR5 = "1.\tData Science. What is data science? The multidisciplinary nature. Data engineering vs. Data science. The role of a data scientist. 2. Knowledge Discovery Process. Formulating questions. Exploratory data analysis. Pre-processing overview. Evaluation overview - Occam’s razor. Information Visualization overview. Documenting the process: Notebooks. 3.\tPre-processing. Data scaling and centring. Data reduction: PCA, SVD, DFT, wavelets, SAX. Data balancing: resampling and SMOTE. Data discretization: equal-width, equal-frequency, taxonomies. Labelling. 4.\tPattern Mining. Association rules - apriori algorithm. Closed vs Maximal patterns. Evaluation metrics: support, confidence, lift and Jaccard 5.\tClustering. Algorithms: K-means, hierarchical. Evaluation: SSE (MSE), silhouette coefficient, Dunn and DB indexes. 6.\tClassification and Regression. Supervised learning: overfitting, training strategies, cross-validation. Linear and logistic regression. Classification Algorithms: KNN, Naive Bayes, Decision trees: metrics and pruning. Ensembles: AdaBoost, Random forests. Evaluation: Metrics (Accuracy, sensibility and specificity, f-measure, ROC area, confusion matrix); ROC and Lift charts 7.\tOutliers detection. 8.\tPrivacy-preserving data mining. 9.\tLarge-scale data mining. Parallelization: map-reduce, online algorithms. Indexing: LSH, Multidimensional. 10.\tCase Studies / Advanced Topics (9h) Time series and sequential analysis. Social Networks analysis; Mining graphs. Recommender Systems, Computational Advertising. Text and opinion mining. Process Mining. Stream Processing and Mining. Computational biology";

    specClassifier.addDocument(objRSIPR5, "Intelligent Systems");
    specClassifier.addDocument(projRSIPR5, "Intelligent Systems");


    ///////////////////////////////////////////////////////////
    /////////////Algorithms and Applications///////////////////
    ///////////////////////////////////////////////////////////
    //Algorithms for Computational Logic - ALC
    let objALC = "Logic is one of the pillars of Computer Science (CS), finding application in all areas of CS. Concrete examples include databases, intelligent information systems, artificial intelligence, but also specification, validation and verification of software, hardware and networks. The main goal of this course is to provide advanced training in approaches for solving logic-based computational problems. Students will be able to analyze, model and solve computationally hard problems using logic. Moreover, students will be able to understand the essential engineering aspects in building software for logic problems: implementation of deductive systems, algorithms and data structures fundamental in the implementation of Logic-based tools.";
    let projALC = "Decision problems in propositional logic (Boolean Satisfiability, SAT).Examples of modelling using propositional logic. Algorithms for SAT. Decision problems in first-order logic. The Satisfiability Modulo Theories (SMT) problem. Problem encodings for SAT. Algorithms for SMT. Constraint Programming (CP): algorithms and modeling examples. Encodings for propositional logic. Answer Set Programming (ASP): algorithms and modeling examples. Relationship with propositional logic. Function and enumeration problems for SAT, SMT, ASP and CP: including optimization problems and over specified sets of constraints. Decision, function and enumeration problems with quantified propositional variables. Application examples.";

    specClassifier.addDocument(objALC, "Algorithms and Applications");
    specClassifier.addDocument(projALC, "Algorithms and Applications");

    //Computability and Complexity - CC
    let objCC = "Characterize computational classes, identify complete sets, distinguish between uniform and nonuniform complexity classes and perform reductions; study open problems in computational complexity.";
    let projCC = "Time and space bounded computations. Structural relations between complexity classes. Bounded resources many-to-one (polynomial time, logarithmic space) and Turing reducibilities. NP-complete, PSPACE-complete and NL-complete sets. The polynomial time hierarchy. Probabilistic Turing machines. Classes PP, BPP, R and ZPP. PP-complete sets. Polynomial time hierarchy. Nonuniform complexity classes and Boolean circuits. P-complete sets. Negative and positive relativisations. Isomorphism and NP-completeness: cylinders and sparse complete sets. Interactive Turing machines: Arthur against Merlin games and proof-systems.";

    specClassifier.addDocument(objCC, "Algorithms and Applications");
    specClassifier.addDocument(projCC, "Algorithms and Applications");

    //Complex Networks Science
    let objARC = "This course provides an introduction to the study of complex networks, including algorithms, models and applications to both artificial and real networks, including social, biological and technological networks, all sharing common features and properties. The course addresses the development of scalable algorithms and data structures so that we can efficiently study large complex networks, but also in the creation of theoretical models capable of describing empirically observed patterns. The number of applications is enormous, including web search engines, evolutionary dynamics, information diffusion on Internet, social networks and blogs, network resilience, network-driven phenomena in epidemiology and computer viruses, networks dynamics, with connections in the social sciences, physics, computational biology, and economics.";
    let projARC = "Introduction to complex systems and networks science: Theory and basic concepts. Properties and characterization of biological, social and technological networks. Network models and random graphs. Efficient representation of large (sparse) networks. Succinct data-structures and coding strategies. Design and analysis of efficient and scalable algorithms for large network processing and analysis, including both sampling and randomization techniques. Databases and distributed platforms for the analysis of large networks. Link analysis and random walks. Community finding and graph partitioning. Ranking algorithms. Vertex relabeling. Dynamical processes on complex networks: The impact of network structure on economic, social and biological systems. Introduction to stochastic processes, Monte-Carlo simulations and large-scale multi-agent systems. Disease spreading and tolerance to attacks. Models of peer-influence and opinion formation. Game theory and population dynamics. Public goods problems, cooperation and reputation dynamics. Decision-making on (static and adaptive) interaction networks.";

    specClassifier.addDocument(objARC, "Algorithms and Applications");
    specClassifier.addDocument(projARC, "Algorithms and Applications");

    //Advanced Algorithms - AAva
    let objAAva = "Data structures and algorithms are the basic building blocks of any computer system and they become even more relevant when such systems have to process huge volumes of data and/or have to meet real time processing requirements. The aim of this course is to provide advanced training in techniques for the development and implementation of efficient algorithms and applications, with particular focus on advanced data structures and algorithms for indexing and compression, and on randomization, sampling and approximation schemes, taking into account real time processing requirements and distributed computing environments. This course will follow a problem based learning approach where techniques and methods will be intuitively and constructively explored.";
    let projAAva = "Advanced data structures. B-trees. Binomial heaps, Fibonacci heaps, and relaxad heaps. Approximation algorithms for NP-hard problems. Probabilistic techniques, random algorithms and game theory. Algorithms with random choices. Online and real-time algorithms. Parallel algorithms and algorithms using external memory. Approximation algorithms for polynomial problems, e.g., linear algorithms for MSTs. Fast algorithms for minimum cuts. Graph partitioning. Approximated counting. String algorithms and pattern matching. Suffix trees and suffix arrays. Tree algorithms, LCA. Amortized Analysis.";

    specClassifier.addDocument(objAAva, "Algorithms and Applications");
    specClassifier.addDocument(projAAva, "Algorithms and Applications");


    ///////////////////////////////////////////////////////////
    /////////////Cyber-Security////////////////////////////////
    ///////////////////////////////////////////////////////////

    //Forensics Cyber-Security - CSF
    let objCSF = "The aim of the course is the study of forensic techniques and methodologies applied to digital evidence. During the course students will seize the different phases of the forensic methodology and its application to the collection and processing of digital evidence gathered form different sources, including evidence gathered from the network, from volatile and persistent memory, and from the memory of mobile devices. In the course the class will also discuss some legal issues relevant to the process of collecting and processing data in order to allow the production evidence in court.";
    let projCSF = "Fundamentals of forensic analysis Methodology Data Type Network Forensics Analysis of network data Analysis of network active systems System Forensics Analysis of Windows systems Analysis of Linux systems Analysis of mobile systems Legal Aspects (U.S., Europe).";

    specClassifier.addDocument(objCSF, "Cyber-Security");
    specClassifier.addDocument(projCSF, "Cyber-Security");

    //Software Security - SSof
    let objSSof = "To understand common software security problems and what are their underlying causes. To become acquainted with guidelines, techniques and tools that can help prevent or detect them, and what are the fundamentally good principles that these techniques embody.";
    let projSSof = "Principles of Computer Security Basic properties and concepts; Software security design principles. •\tSoftware Vulnerabilities Conventional applications (buffer overflows, race conditions); Web applications and databases; Mobile application; Client-side security; •\tDevelopment of secure software Software auditing; Validation and encoding. •\tControl of execution environment Dynamic protection; Virtualization and security; Trusted computing. •\tLanguage Based Security Information flow analysis; Security type systems; Secure low-level code; Proof carrying code. •\tA Case Study: Java Security Sandboxing and stack inspection; Java security flaws; Java secure programming guidelines.";

    specClassifier.addDocument(objSSof, "Cyber-Security");
    specClassifier.addDocument(projSSof, "Cyber-Security");

    //Network and Computer Security - SIRS
    let objSIRS = "The main goal of this curse is to provide the students with the basic set of concepts, methodologies and tool on computer and network security. This will make them comfortable with the broad set of technologies such as: local and global networks, personal and private networks, development of secure code, operating systems, distributed systems, and communications protocols.";
    let projSIRS = "•\tIntroduction •\tNetwork security and vulnerabilities •\tFirewalls and intrusion detection systems •\tDevelopment of secure code • Certification •\tSymmetrical and asymmetrical encryption and cryptographic hash functions •\tMessage authentication and digital signatures •\tDistribution protocols and management of symmetrical keys •\tDigital certificates and public key distribution infrastructures •\tAuthentications and authentication protocols •\tAuthorization •\tWireless networks security •\tVirtual private networks and secure channels";

    specClassifier.addDocument(objSIRS, "Cyber-Security");
    specClassifier.addDocument(projSIRS, "Cyber-Security");

    //Cryptography and Security Protocols - CPS
    let objCPS = "Master cryptosystems and cryptographic protocols in current use, develop protocols to solve specific problems and forecast future developments.";
    let projCPS = "Basic concepts and central problems in cryptography. Private key cryptosystems. Sequential ciphers. Contribution of information theory. Attacks: divide to conquer and fast correlation. Block ciphers. Examples: DES and AES. Perfect and computational security. Public key cryptosystems. RSA cryptosystem. Factoring and primality algorithms. Quantum critpoanalysis. Projective coordinates. Elliptic curves. Gauss integers. Euclidean algorithm for polynomials. Hilbert theorem. Gröbner bases. Elliptic and hyperelliptic cryptosystems. Public key protocols. ElGamal signature scheme and DSS. Elliptic curve digital signature algorithms. Blind signatures. Hash functions. Diffie-Hellman key exchange scheme. Quantum key distribution protocols. Station to station and MTI protocols. Authentication codes. Shamir secret sharing scheme. Zero-knowledge proof systems. Schnorr and Fiat-Shamir identification protocols. Muti-party secure computation and applications.";

    specClassifier.addDocument(objCPS, "Cyber-Security");
    specClassifier.addDocument(projCPS, "Cyber-Security");

    ///////////////////////////////////////////////////////////
    /////////////Games/////////////////////////////////////////
    ///////////////////////////////////////////////////////////

    //Computer Graphics for Games - CGJ
    let objCGJ = "This course covers both theory and practice of game engine software development. It delves into the different engine subsystems including, but not limited to, rendering, character animation, and physics, and details the articulation required to support gameplay development. By the end of this course, students should understand how modern game engines work, and be able to design and develop their own game engines.";
    let projCGJ = "Introduction to game engine development. Architecture of a game engine. Asset pipeline and management. Real-time simulation loops. Human interface devices. 3D mathematics for games. Viewing pipeline: modelling, viewing, lighting, texturing. GPU rendering pipeline and shader programming. Visual effects. Advanced lighting, global illumination and shadows. Scene management. Animation systems. Collision and rigid body dynamics. Audio systems. Online multiplayer/networking. Runtime gameplay systems.";

    specClassifier.addDocument(objCGJ, "Games");
    specClassifier.addDocument(projCGJ, "Games");

    //Game Design - DDJ
    let objDDJ = "This course grants the students the opportunity to develop their skills on experience design and prototyping for games. The learning process is sustained in the discussion of what is a game, what are its components and what is its relation to the players (having in mind their differences). It is expected that the student develop design documents and prototypes to support his/her work on the course.";
    let projDDJ = "Components of game design Definitions of game and play History of videogames: classic and modern examples Game theory Player models Player experience Theory of fun Gameplay: world, scenarios, abstractions, progression and balancing Categorization: game genres and challenges Narrative and character development Emotion in games The creative process Documentation: concept, treatment and script Game design rules The business of games and entrepreneurship";

    specClassifier.addDocument(objDDJ, "Games");
    specClassifier.addDocument(projDDJ, "Games");

    //Artificial Intelligence in Games - IAJ
    let objIAJ = "1.\tUnderstand the differences between traditional AI and AI applied to game development, where other factors such as playability are more relevant that the oponent’s intelligence level. 2.\tBe familiar with the practical problems when developing AI for video games, and with the several techniques applied in comercial video games. 3.\tKnow how to design and build an AI system for a video game independently of its genre (action, sport, strategy, narrative).";
    let projIAJ = "1.\tIntroduction.AI in Games: the Complexity Fallacy; the kind of AI in Games; speed and memory; the AI Engine. 2.\tPathfinding: Pathfinding graph; Dijkstra; A*; Improving A*;World Representations; hierarchical pathfinding; Continuous Time Path-finding; Movement Planning. 3.\tMovement: the basics of movement algorithms; kinematic movement algorithms; steering behaviours; predicting physics; coordinated movement; motor control. 4.\tDecision making: decision trees; state machines; behavior trees; fuzzy logic; goal-based behavior; rule-based systems 5.\tAI Tactics and Strategy: waypoints tactics; tactical analysis; tactical pathfinding; coordinated actions. 6.\tLearning in games: learning basics; parameter modification; action prediction; decision learning; Naïve bayes classifier; decision trees; user modeling. 7.\tBoard Games: minimax algorithm; transposition tables; memory-enhanced test algorithms; Turn-based strategy games. 8.\tDesigning game AI: the design; shooters; driving; real-time strategy; sports; turn-based strategy. 9.\tAI and Interactive Narrative.";

    specClassifier.addDocument(objIAJ, "Games");
    specClassifier.addDocument(projIAJ, "Games");

    //Game Development Methodology - TJS
    let objTJS = "Present a vision of the different methodologies and technologies involved in the development of digital games discussing the main features and issues in each one. Grant students with conceptual tools and techniques to develop user interfaces for games with special emphasis on player controls. Develop the ability to reflect and test the player experience and gameplay. Discuss the role of conceptual modelling and user testing. Highlight the importance to take a user centred approach in the exploration of the player experience.";
    let projTJS = "The game as an interactive artefacts Involving players in the development. Agile development. Phases of game development. Interaction models. Interface types. World and player representation. Control metaphors Conceptual modelling for player experience. Economic models and dynamics models. Playtesting in the development process. Method and techniques of data gathering and analisys. Prototyping. Level design. Gameplay/Player analytics. Adaptation to the player.";

    specClassifier.addDocument(objTJS, "Games");
    specClassifier.addDocument(projTJS, "Games");

    ///////////////////////////////////////////////////////////
    ////////////     Bioinformatics and Computational Biology//
    ///////////////////////////////////////////////////////////

    //TODO Bioinformatics override the other areas, so a custom classification is given
    /*
    //Bioinformatics  - Bioi
    let objBioi = "Bioinformatics aims at developing computational methods and algorithms to process biological data and uses mathematical and statistical modelling to generate testable hypotheses about biological entities and processes. The goal of this course is to introduce the basic techniques that support the most recent developments on this field. Additionally, it enables the development of the ability to critically assess research publications in this field. Practical assignments during the course aim at developing the student\'s ability to develop software for bioinformatics.";
    let projBioi = "Introduction, Molecular biology main concepts, Introduction to algorithms and complexity Graphs and genetics DNA sequence analysis Pairwise alignment Multiple Sequence alignment Motif finding NGS data, algorithms and data structures Probabilistic models Gene expression data analysis Data mining Unsupervised Learning: Clustering and Biclustering Molecular phylogenetics Supervised Learning: Decision trees, Bayesian methods Integrative data analysis Seminar";

    specClassifier.addDocument(objBioi, "Bioinformatics and Computational Biology");
    specClassifier.addDocument(projBioi, "Bioinformatics and Computational Biology");

    //Health Ict - TIS
    let objTIS = "The general objective of the course is to provide the fundamental principles and concepts related to the use of information technology in health care. The students will acquire essential competencies and knowledge on the use of information technology in biomedical research and its crucial role in the provision of health care services.";
    let projTIS = "1. Information Technology in the life sciences 2. Clinical information systems 3. Acquisition processing and use of biomedical data. The Electronic Health Record. 4. Health Informatics data interchange standards. Thesauri and Ontologies. 5. Natural language processing and biomedical text mining. 6. Clinical Decision-support Systems. 7. Tele-monitoring 8. Tele-Health 9. Bioinformatics and Biomedical Research Infrastructures. 10. Information Search 11. Personalised medicine 12. Ethical Legal and Social Issues in IT in Health. 13. Public Health Informatics 14. IT for Healthy Living and Active Ageing. Consumer Health Informatics. 15. IT in user training and education of health professionals";

    specClassifier.addDocument("Rui Miguel Carrasqueiro Henriques", "Bioinformatics and Computational Biology");
    specClassifier.addDocument("Arlindo Oliveira", "Bioinformatics and Computational Biology");
    specClassifier.addDocument("Bioinformatics and Computational Biology", "Bioinformatics and Computational Biology");

    */


    ///////////////////////////////////////////////////////////
    ////////////    Language and Information Technologies//////
    ///////////////////////////////////////////////////////////

    //Natural Language - LN
    let objLN2 = "•\tLearn the basic concepts, main formalisms, techniques and algorithms, knowledge bases and corpora, used in the Natural Language Processing area. •\tUnderstand the main tasks involved in the processing of a sentence, paragraph or text and understand the main challenges of each one of these tasks. •\tLearn the main applications and be able to identify the associated technology. •\tUnderstand which are the tasks that can be done considering the current state of the art.";
    let projLN2 = "Course overview (1h) Introduction to Natural Language Processing (3h 30) Basic concepts Ambiguity and linguistic variability Associated knowledge Methodology: Train/test corpus, Cross validation, Measures (precision, recall, etc.) Regular expressions and automata (1.5h) N-Grams (4.5 h) N-grams as language models Markov assumption and probabilities of an N-gram/sentence Smoothing techniques Morphology (9) Morphology and transducers Part of speech tagging (POS) Rule-based and stochastic HMMS and Viterbi algorithm Syntax (9h) Grammars Context-free grammars Dependency grammars Probabilistic grammars Syntactic analysis Unification-based Top-down and Bottom-up Chat-parsers (Earley e CKY) Probabilistic Semantic (9h) Meaning representation Lexical semantics Thematic roles Semantic disambiguation Semantic analysis Compositional semantic analysis Statistic-based semantic analysis Classifiers and their application in semantic analysis Applications (remaining classes) Information extraction (named entity recognition, etc.) Text classification Question/answering systems Dialogue systems Machine translation Speech recognition";

    specClassifier.addDocument(objLN2, "Language and Information Technologies");
    specClassifier.addDocument(projLN2, "Language and Information Technologies");

    //Information Processing and Retrieval - RGI
    let objRGI = "This course aims to provide the students with an complete and updated introduction to the key-concepts and technologies used for data processing in the areas of Information Retrieval (IR), Information filtering (IF) and Information Extraction (IE). Students of this course will learn the basic theoretical concepts and acquire the practical skills needed to: 1.\tDesign modern solution for processing, managing and querying large volumes of information; 2.\tClassify and group automatically sets of resources (e.g. large sets of textual documents); 3.\tDesign search and filtering mechanisms for large collections; 4.\tDesign systems to extract information from text and/or the Web; 5.\tEvaluate empirically such systems.";
    let projRGI = "•\tIntroduction to Information Retrieval and Information Extraction ◦\tIR system architecture ◦\tDocument pre-processing •\tNon-structured data models ◦\tBoolean model ◦\tVector-space model ◦\tDimensionality reduction ◦\tProbabilistic models •\tInformation Extraction from text ◦\tClassification and clustering of documents ◦\tThe naive Bayes classifier ◦\tInformation Extraction with hidden Markov models • Evaluation of IR Systems ◦\tEvaluation metrics ◦\tReference collections ◦\tCross-validation and other issues •\tSemi-structured data models ◦\tSemi-structured data models ◦\tThe Extensible Markup Language (XML) ◦\tMarkup languages based on XML (e.g., TEI, METS, MODS) ◦\tOther languages (e.g., SGML, HTML e RDF) •\tWeb Data Extraction ◦\tWrapper generation ◦\tThe XQuery language ◦\tIR in XML documents •\tLink analysis ◦\tWeb models ◦\tBasic concepts on graphs and link analysis ◦\tUsing links to rank documents ◦\tWeb crawling •\tIndexing and querying non-structured information ◦\tRegular expressions ◦\tInverted Indexes ◦\tQuery processing •\tSimilarity search ◦\tDocument shingling and the Jaccard similarity measure ◦\tSimilarity-preserving summaries of sets and min-hash ◦\tLocality-sensitive hashing ◦\tApplications in multimedia retrieval •\tRecommendation systems ◦\tContext, personalization and information filtering ◦ Content-based recommendations ◦\tCollaborative filtering •\tDistributed processing for IR and IE ◦\tData partitioning ◦\tFederated search and meta-search engines ◦\tMap-Reduce processing •\tIE and IR applications ◦\tEnterprise search and expert search ◦\tDigital libraries ◦ Opinion mining ◦\tOther applications";

    specClassifier.addDocument(objRGI, "Language and Information Technologies");
    specClassifier.addDocument(projRGI, "Language and Information Technologies");

    //Spoken Language Processing - PF
    let objPF = "At the end of the course students are supposed to know the basic principles and techniques of speech coding, synthesis and recognition.";
    let projPF = "Spoken Language Processing The course is structured into 7 chapters. The first introductory chapter presents the goals of the course, and the main applications of spoken language processing. It also briefly reviews the digital signal processing concepts that are needed in this course. The second chapter discusses the way humans generate and perceive speech, describing the production and audition/perception mechanisms. The next four chapters study the way computers try to mimic this human performance, including speech signal analysis techniques, speech coding models, text-to-speech conversion (synthesis) and speech-to-text conversion (recognition) techniques. The last of these four chapters covers not only the speech recognition area but also the speaker and language recognition areas. The final chapter frequently includes talks by researchers of other areas of natural language processing (namely from other faculties) and/or visits to labs. The course is planned for 27 theory classes of 1h30 each. 1 - 2 classes 2 - 3 classes 3 - 4 classes 4 - 3 classes 5 - 5 classes 6 - 8 classes 7 - 2 classes";

    specClassifier.addDocument(objPF, "Language and Information Technologies");
    specClassifier.addDocument(projPF, "Language and Information Technologies");


    //Manual adjustments
    specClassifier.addDocument("Laboratório de Sistemas de Língua Falada - L2F (INESC-ID Lisboa)", "Language and Information Technologies");
    specClassifier.addDocument("Alberto Abad", "Language and Information Technologies");
    specClassifier.addDocument("fixed expressions", "Language and Information Technologies");
    specClassifier.addDocument("popular sayings", "Language and Information Technologies");
    specClassifier.addDocument("speech therapy", "Language and Information Technologies");
    specClassifier.addDocument("Development of a mobile application for speech therapy", "Language and Information Technologies");


    specClassifier.addDocument("Nuno Jardim Nunes", "Interaction and Visualization");
    specClassifier.addDocument("Alfredo Ferreira", "Interaction and Visualization");
    specClassifier.addDocument("João Brisson", "Interaction and Visualization");
    specClassifier.addDocument("Joaquim Jorge", "Interaction and Visualization");
    specClassifier.addDocument("Daniel Jorge Viegas Gonçalves", "Interaction and Visualization");
    specClassifier.addDocument("Hugo Miguel Aleixo Albuquerque Nicolau", "Interaction and Visualization");
    specClassifier.addDocument("Jacinto Carlos Marques Peixoto do Nascimento", "Interaction and Visualization");
    specClassifier.addDocument("Augmenting Rehabilitation", "Interaction and Visualization");
    specClassifier.addDocument("Virtual Reality", "Interaction and Visualization");
    specClassifier.addDocument("Design", "Interaction and Visualization");
    specClassifier.addDocument("Experience", "Interaction and Visualization");
    specClassifier.addDocument("Collaborative Modeling", "Interaction and Visualization");
    specClassifier.addDocument("AR on Smartphones", "Interaction and Visualization");
    specClassifier.addDocument("Flat Design", "Interaction and Visualization");
    specClassifier.addDocument("Sensing", "Interaction and Visualization");
    specClassifier.addDocument("Visualizing", "Interaction and Visualization");


    specClassifier.addDocument("network fault injection", "Cyber-Security");
    specClassifier.addDocument("Security", "Cyber-Security");
    specClassifier.addDocument("Artificial Intelligence in Security", "Cyber-Security");
    specClassifier.addDocument("REST APIs", "Cyber-Security");
    specClassifier.addDocument("Communication Contracts", "Cyber-Security");
    specClassifier.addDocument("Verification", "Cyber-Security");


    specClassifier.addDocument("Smart-Graphs", "Algorithms and Applications");
    specClassifier.addDocument("Constraint Logic", "Algorithms and Applications");


    specClassifier.addDocument("microservices architecture", "Software Engineering");
    specClassifier.addDocument("Framework", "Software Engineering");
    specClassifier.addDocument("Virtualization", "Software Engineering");
    specClassifier.addDocument("Dynamic API Invocation", "Software Engineering");
    specClassifier.addDocument("monolithic architecture", "Software Engineering");
    specClassifier.addDocument("António Paulo Teles de Menezes Correia Leitão", "Software Engineering");
    specClassifier.addDocument("António Rito Silva", "Software Engineering");
    specClassifier.addDocument("Responsive Web Applications", "Software Engineering");
    specClassifier.addDocument("Service Virtualization Framework", "Software Engineering");
    specClassifier.addDocument("Mobile Application", "Software Engineering");
    specClassifier.addDocument("Mobile", "Software Engineering");
    specClassifier.addDocument("App", "Software Engineering");


    specClassifier.addDocument("NPC", "Games");
    specClassifier.addDocument("Digital Games", "Games");
    specClassifier.addDocument("Digital Games", "Games");
    specClassifier.addDocument("Digital Games", "Games");
    specClassifier.addDocument("Digital Games", "Games");
    specClassifier.addDocument("Digital Games", "Games");
    specClassifier.addDocument("Games", "Games");
    specClassifier.addDocument("Game", "Games");
    specClassifier.addDocument("tactically", "Games");
    specClassifier.addDocument("João Miguel De Sousa de Assis Dias", "Games");
    specClassifier.addDocument("Carlos António Roque Martinho", "Games");
    specClassifier.addDocument("Rui Filipe Fernandes Prada", "Games");


    specClassifier.addDocument("Architecture", "Enterprise and Information Systems");
    specClassifier.addDocument("Support Services for Digital Operations Transformation", "Enterprise and Information Systems");
    specClassifier.addDocument("Digital Transformation", "Enterprise and Information Systems");
    specClassifier.addDocument("IT Project Management", "Enterprise and Information Systems");
    specClassifier.addDocument("Enterprise Architecture", "Enterprise and Information Systems");
    specClassifier.addDocument("Business Architecture", "Enterprise and Information Systems");
    specClassifier.addDocument("COBIT", "Enterprise and Information Systems");
    specClassifier.addDocument("Modeling", "Enterprise and Information Systems");
    specClassifier.addDocument("Archimate", "Enterprise and Information Systems");
    specClassifier.addDocument("Startup", "Enterprise and Information Systems");
    specClassifier.addDocument("Business processes", "Enterprise and Information Systems");
    specClassifier.addDocument("Sérgio Luís Proença Duarte Guerreiro", "Enterprise and Information Systems");


    specClassifier.addDocument("robots", "Intelligent Systems");
    specClassifier.addDocument("behavior for robots", "Intelligent Systems");
    specClassifier.addDocument("Change Detection on Frequent Patterns", "Intelligent Systems");
    specClassifier.addDocument("Matching", "Intelligent Systems");
    specClassifier.addDocument("Matching", "Intelligent Systems");


    specClassifier.addDocument("Urban transport", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("IoT", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("Domotic", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("Internet-of-Things", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("Framework", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("Rui Policarpo Duarte", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("Horácio Neto", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("OpenCL", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("processor", "Distributed and Cyberphysical Systems");
    specClassifier.addDocument("P3", "Distributed and Cyberphysical Systems");

    specClassifier.train();
    return specClassifier;
}

module.exports = { trainSpecializationAreasClassifier }